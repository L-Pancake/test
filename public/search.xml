<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Canvas学习笔记]]></title>
      <url>%2F2016%2F11%2F21%2FCanvasLearn%2F</url>
      <content type="text"><![CDATA[canvas实例 canvas时钟动效时钟 canvas粒子动效以前在网上看到过，学了canvas后觉得可以做便做了出来粒子动效2016-11-26 canvas深入学习绘图环境获取12var canvas = document.getElementById(&apos;canvas&apos;);var context = canvas.getContext(&apos;2d&apos;); context即为2d绘图环境 moveTo(x,y)函数context.moveTo(100,100);将画笔移动到（100，100）的位置，其中画布的左上角为坐标原点，向右为x正方向，向下为y正方向。 lineTo(x,y)函数123context.moveTo(100,100);//状态context.lineTo(200,200);//状态context.stroke();//绘制动作 绘制一条从（100，100）到（200，200）的直线。 绘制折线1234context.moveTo(100,100);context.lineTo(200,200);context.lineTo(200,300);context.stroke();//绘制动作 绘制一条从（100，100）到（200，200）再到（200，300）的折线。 线条属性 lineWidthcontext.lineWidth=10;设置了直线宽度 strokeStylecontext.strokeStyle=&quot;#058&quot;;设置了直线颜色 lineCap（线段两端样式）context.lineCap=&quot;butt&quot;;（只适用于线段的开始和结束） butt(default) 默认 round 圆角 square 方角（可以产生和closePath一样的闭合效果) lineJion(线段相交处样式) miter(default) 尖角 bevel 斜接 round 圆角 canvas是基于状态绘图的beginPath()方法context.beginPath() 用于全新绘制一段路径，如果一个属性值没有被改变，那么beginPath方法依然会保持这一个属性。 closePath()方法context.closePath() 用于绘制一段闭合路径，可以解决线段宽度问题，并且可以省略一个lineTo函数。 fillStyle属性 fill()方法 简单用法12context.fillStyle=&quot;yellow&quot;;context.fill(); 用于填充多边形的颜色。对调fill()和stroke()方法的顺序可以解决描边被覆盖的问题。 渐变色用法 Linear Gradient线性 12345var skyStyle=context.createLinearGradient(0,0,0,canvas.height);//创建渐变线skyStyle.addColorStop(0.0,&quot;black&quot;);//添加颜色关键值 浮点数代表颜色在渐变线的位置skyStyle.addColorStop(1.0,&quot;#305&quot;);//添加颜色关键值context.fillStyle = skyStyle;context.fillRect(0, 0, canvas.width, canvas.height); Radial Gradient径向 123456789101112131415161718//创建 参数为第一个圆形的原点和半径 第二个圆的原点和半径var skyStyle=context.createRadialGradient(x0,y0,r0,x1,y1,r1);skyStyle.addColorStop(0.0,&quot;black&quot;);//添加颜色关键值 浮点数代表颜色在渐变线的位置skyStyle.addColorStop(1.0,&quot;#305&quot;);//添加颜色关键值context.fillStyle = skyStyle;context.fillRect(0, 0, canvas.width, canvas.height);``` - createPattern ```Javascript var backgroundImage=new Image(); backgroundImage.src=&quot;example,jpg&quot;; backgroundImage.onload=function()&#123; //参数为no-repeat repeat repeat-x repeat-y //backgroundImage还可以用canvas画布或vide var pattern=context.createPattern(backgroundImage,&quot;no-repeat&quot;); context.fillStyle=pattern; context.fillRect(0,0,800,800); &#125; 同样fillStyle的特性也适用于strokeStyle上。 绘制矩形 rec(x,ywidth,height)函数 单纯绘制矩形 fillRect(xy,width,height)函数 绘制矩形并且应用当前填充色 strokeRect(x,y,width,height)函数 绘制矩形并且应用当前描边颜色 颜色的表示 rgb(255,255,255) 数字分别对应红，绿，蓝 rgba(255,255,255,0.8) 数字分别对应红，绿，蓝，透明度 圆形绘制arc(x,y, RADIUS, 0, p, bool)函数 context.arc(100,100, 10, 0, 0, 2 * Math.PI, true); 图形变换综合考虑是否使用图形变换。 位移 translate(x,y)存在陷阱 12345678910111213141516171819202122232425262728293031var context=canvas.getContext(&quot;2d&quot;);context.fillStyle=&quot;red&quot;;context.translate(100,100);context.fillRect(0,0,400,400);context.fillStyle=&quot;green&quot;;context.translate(300,300);context.fillRect(0,0,400,400);/*你以为green方形移动到了（300,300）？其实不然，它实际上移动到了（400,400），因为translate是可叠加的。为此我们可以在绘图结束后再反向操作。*/var context=canvas.getContext(&quot;2d&quot;);context.fillStyle=&quot;red&quot;;context.translate(100,100);context.fillRect(0,0,400,400);context.translate(-100,-100);//context.fillStyle=&quot;green&quot;;context.translate(300,300);context.fillRect(0,0,400,400);context.translate(-300,-300);///*或者使用（**推荐使用**）*/var context=canvas.getContext(&quot;2d&quot;);context.save();//context.fillStyle=&quot;red&quot;;context.translate(100,100);context.fillRect(0,0,400,400);context.restore();//context.save();//context.fillStyle=&quot;green&quot;;context.translate(300,300);context.fillRect(0,0,400,400);context.restore();// 旋转 rotate(deg) 缩放 scale(sx,sy)注意 scale不仅改变了大小还改变了初设的(x,y),lineWidth属性，可适当放弃一些效果来减小副作用或者自己设计方法解决。 transform(a,b,c,d,e,f)函数对应一个变换矩阵 123|a c e|= |1 0 0| |b d f|= |0 1 0| |0 0 1|= |0 0 1| a水平缩放（1） b水平倾斜（0） c垂直倾斜（0） d垂直缩放（1） e水平位移（0） f垂直位移（0)多次调用产生效果为叠加。 setTransform(a,b,c,d,e,f)函数用于忽略掉之前的所有transform,重置为单位矩阵，再按照setTransform函数中的参数进行变换。 123context.transform(1,0,0,1,50,100);context.transform(2,0,0,1.5,0,0);context.setTransform(1,0,0,1,100,100); 最终保留setTransform的变换。 曲线绘制 artTo(x0,y0,x1,y1,r)终止于切点处 Bezier quadraticCurveTo(x0,y0,x1,y1)(x0,y0)为控制点， (x1,y1)为终点 bezierCurveTO(x0,y0,x1,y1,x2,y2)(x0,y0)， (x1,y1)为控制点， (x2,y2)为终点 文字context.font属性 font-style normal(default) italic(倾斜字) oblique（倾斜字体） font-variant normal(default) small-caps(英文小写字母变成小型大写字母) font-weight lighter(新) normal(default) bold bolder(新) 100,200,300,400(normal),500,600,700(bold),800,900 font-size px em % font-family 图形关系 globalAlpha globalCompositeOperation source-over 后面图形遮盖前面 source-atop source-in source-out destination-over 前面图形遮盖后面 destination-atop destination-in destination-out lighter copy xor 剪辑区域clip()剪切出一个区域用于绘制 点击判断isPointInPath(x,y)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sass学习笔记]]></title>
      <url>%2F2016%2F11%2F13%2FSassLearn%2F</url>
      <content type="text"><![CDATA[文件后缀名统一使用.scss，区分大小括号 默认变量在末尾加入!default即可,例如$baseLineHeight: 1.5 !default;sass的默认变量一般是用来设置默认值，然后根据需求来覆盖的，覆盖的方式也很简单，只需要在默认变量之前重新声明下变量即可12$baseLineHeight: 2;$baseLineHeight: 1.5 !default; 多值变量 listlist数据可通过空格，逗号或小括号分隔多个值，可用nth($var,$index)取值。 1234567$linkColor: #08c #333 !default;//第一个值为默认值，第二个鼠标滑过值a&#123; color:nth($linkColor,1); &amp;:hover&#123; color:nth($linkColor,2); &#125;&#125; mapmap数据以key和value成对出现，其中value又可以是list。格式为：$map: (key1: value1, key2: value2, key3: value3);。可通过map-get($map,$key)取值。 123456$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings &#123; #&#123;$header&#125; &#123; font-size: $size; &#125;&#125; 全局变量在变量值后面加上!global即为全局变量。这个目前还用不上，不过将会在sass 3.4后的版本中正式应用。目前的sass变量范围饱受诟病，所以才有了这个全局变量。 目前变量机制在选择器中声明的变量会覆盖外面全局声明的变量。(这也就人们常说的sass没有局部变量) @at-root跳出选择器嵌套12345678910111213141516171819202122232425262728//sass style//-------------------------------//没有跳出.parent-1 &#123; color:#f00; .child &#123; width:100px; &#125;&#125;//单个选择器跳出.parent-2 &#123; color:#f00; @at-root .child &#123; width:200px; &#125;&#125;//多个选择器跳出.parent-3 &#123; background:#f00; @at-root &#123; .child1 &#123; width:300px; &#125; .child2 &#123; width:400px; &#125; &#125;&#125; @at-root (without: …)和@at-root (with: …)默认@at-root只会跳出选择器嵌套，而不能跳出@media或@support，如果要跳出这两种，则需使用@at-root (without: media)，@at-root (without: support)。这个语法的关键词有四个：all（表示所有），rule（表示常规css），media（表示media），support（表示support，因为@support目前还无法广泛使用，所以在此不表）。我们默认的@at-root其实就是@at-root (without:rule)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavascriptDOM 编程艺术]]></title>
      <url>%2F2016%2F11%2F03%2FJavascriptDOM%2F</url>
      <content type="text"><![CDATA[重要的DOM Core方法 getElementById getElementByTagName getAttribute setAttribute example.setAttribute(“id”,”idName”) DOM Core方法和HTML-Core方法区别childNodes属性用于获取所有子元素 nodeType属性 元素节点 nodeType值是1。例如 div ,p 属性节点 nodeType值为2。例如 title 文本节点 nodeType值为3。例如 “hello world” nodeValue属性 firstChild获取的数组中的第一个元素 lastChild获取的数组中的最后一个元素 三个重要的函数 addLoadEvent方法1234567891011function addLoadEvent(func)&#123;var oldonload = window.onload;if(typeof window.onload != &apos;function&apos;)&#123; window.onload = func; &#125;else&#123; window.onload = function()&#123; oldonload(); func(); &#125; &#125;&#125; if(typeof window.onload != ‘function’)的作用是判断window.onload事件有没有绑定函数。 insertAfter函数12345678function insertAter(newElement,targetElement)&#123; var parent = targetElement.parentNode; if(parent.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125;else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; 用于把新元素插入到一个元素之后 addClass函数12345678910function addClass(element,value)&#123;if(!element.className)&#123; elment.className = value; &#125;else&#123; newClassName = element.className; newClassName += &quot; &quot;; newClassName += value; element.className = newClassName; &#125;&#125; innerHTML属性方便大段替换 createElement方法用于创造新的元素使用方法document.createElement(&quot;nodeName&quot;); appendChild方法用于把新的元素放到html文档中使用方法parent.appendChild(&quot;child&quot;); createTextNode方法用于创建一个文本节点使用方法var txt = document.createTextNode(&quot;hello world&quot;);再使用appendChild()即可。 insertBefore方法用于把新元素插入到一个元素之前 三要素 新元素newElement 目标元素tragetElement 父类元素parentElement使用方法parentElement.insertBefore(newElement,targetElement) nextSibling属性用于获取下一个兄弟元素 for(key in defs){}key=nodeValue[key]=definition 用DOM技术访问font-family错误方法 element.style.font-family正确方法 element.style.fontFamily即才用驼峰法访问，但是外部链结样式无法访问(用DOM技术添加的就没问题)DOM设置style必须要用引号括起来para.style.color = &quot;black&quot; 设置表格奇数和偶数行样式的方法12tr:nth-child(odd)&#123;background-color:#ffc;&#125;tr:nth-child(even)&#123;background-color:#fff;&#125; @import url()用于把样式表都导入到一个文件中例如 layout.css color.css typography.css 1234//basic.css@import url(layout.css);@import url(color.css);@import url(typography.css); HTML DOM form对象每个form对象都有一个element.length属性，其返回表单中包含的单元个数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MyFirstBlog]]></title>
      <url>%2F2016%2F10%2F31%2FMyFirstBlog%2F</url>
      <content type="text"><![CDATA[前言在百度上搜索了大量的文档后终于搭建成功，在此想总结一下整个hexo blog的搭建过程。 安装Git直接到Git的官网下载安装即可， 对于Git教程的话可以参考廖雪峰的git教程。 Git安装问题“git”不是内部指令解决方法：需要配置git的环境变量确定git的安装目录，我的是C:\Program Files\Git。打开环境变量配置界面，win10的操作为：win键-&gt;设置-&gt;系统-&gt;关于-&gt;系统信息-&gt;高级系统设置-&gt;环境变量 得到如下图所示。可以看到win10的变量配置分为了用户变量和系统变量，而我们需要配置的是系统变量中的PATH的值首先点击新建，并且在输入框中随意输入一个字符（这样做可以避免原有环境变量被覆盖），然后点击浏览，浏览到git的安装目录下单击选中bin文件夹，最后点击确认即可。打开CMD输入git --help见到这个就说明成功了。 安装node.js直接到node.js的官网下载安装即可。（暂时没发现node.js的问题）打开CMD输入：node -v输出类似如下的版本号即可：v7.0.0 安装hexo在这之前请确保git与node.js安装成功。打开CMD输入：$ npm install -g hexo-cli若出现error，请确保你的git版本与node的版本为最新版。打开CMD输入：$ hexo -v输出类似如下的信息即可：1234567891011hexo-cli: 1.0.2os: Windows_NT 10.0.14393 win32 x64http_parser: 2.7.0node: 7.0.0v8: 5.4.500.36uv: 1.9.1zlib: 1.2.8ares: 1.10.1-DEVicu: 57.1modules: 51openssl: 1.0.2j 安装hexo主题这里使用NexT的主题。轻快简洁，且适配多种媒体。这是一款轻快简洁、适配多种媒体的主题，并且主题配备了十分完善的文档。我们只需按照步骤走一遍即可。 配置主题过程中我遇到的问题如何设置网页缩略图标打开主题配置文件（yourBlog\themes\next_config.yml)，找到12# Put your favicon.ico into `hexo-site/source/` directory.favicon: 字段，添加图片网址后更改为12# Put your favicon.ico into `hexo-site/source/` directory.favicon: https://example.png 配置github 到github官网注册一个账号； 登陆后点击绿色按钮（New repository），然后输入Repository name其格式要求为：用户名.git.io例如用户名为pancake则输入pancake.git.io 最后点击create按钮即可。 将hexo博客部署到github上在这一步之前你需要参照廖雪峰git教程把本地仓库和远程仓库建立连接。打开站点配置文件（yourBlog_config.yml），找到123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repository: branch: 字段，并更改为123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git//hexo3.0版本之后已经从github改为了git repository: https://github.com/yourName/yourName.github.io.git//你刚刚远程创建的仓库地址 branch: master//仓库分支 完成后打开CMD，进入到博客的目录下，输入：$ npm install hexo-deployer-git --save等待片刻再输入$ hexo deploy最后打开浏览器输入：http://**yourName**.github.io/ 查看即可。 更改博文后再次提交到github你需要按照如下步骤进行操作使用CMD进入到博客目录下，然后依次输入：123$ hexo clean$ hexo generate$ hexo deploy 最后再次刷新页面即可。最终效果如图。 hexo草稿功能在blog根目录下使用$ hexo new draft &quot;new draft&quot;创建草稿可以使用$ hexo server --drafts来在本地浏览器预览博文若想发布文章，只需要把md文件中的layout: draft删除即可。 上传github博客只有框架没有内容的问题GitHub Pages 过滤掉了 source/vendors 目录的访问,所以deploy之后打开主页是一片空白。解决方案是更新主题文件或者手动配置。手动将 source/vendors 目录修改成 source/lib(或是其他的名称，lib亲测可用)。同时,修改下主题配置文件_config.yml, 将internal: vendors 改成你所修改的名字。来源于知乎]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F10%2F30%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
